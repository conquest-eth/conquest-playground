import{h as y,o as E}from"./config-af7f3a10.js";import{ac as S,ad as I,ae as C,F as A,af as K,a6 as W,a9 as N}from"./vendor-e78c39f1.js";import{w as o,f as _,c as x}from"./wallet-c826be1b.js";import{b as f}from"./paths-28a87002.js";import{i as p}from"./contracts-69d01f63.js";const{compressToUint8Array:G,decompressFromUint8Array:$}=I,Y=S;function P(i,t){return C(Math.floor(i)*1e3,t)}function J(i,t){return i===void 0?!1:(i&Math.pow(2,t))==Math.pow(2,t)}function Q(i){var s,e,n;const t=((s=i.data)==null?void 0:s.message)||(((e=i.data)==null?void 0:e.data)?JSON.stringify((n=i.data)==null?void 0:n.data):i.message?i.message:JSON.stringify(i));return t.indexOf(" could not be found")!==-1?`${y}'s node out of sync: "block ${t}"`:t.indexOf("No state available for block ")!==-1?`${y}'s node out of sync: "${t}"`:t}function F(i){i=i.trim(),i.startsWith("(")&&(i=i.slice(1)),i.endsWith(")")&&(i=i.slice(0,i.length-1));const t=i.split(",").map(s=>s.trim());if(t.length===2){const s=parseInt(t[0]),e=parseInt(t[1]);if(!isNaN(s)&&!isNaN(e))return{x:s,y:e}}throw new Error("invalid coords")}class O{constructor(t){this._prefix=f&&f.startsWith("/ipfs/")||f.startsWith("/ipns/")?f.slice(6):"_l_";const s=this.getItem("_version");s!==t&&(console.log("new version, clear old storage...",{lastVersion:s,version:t}),this.clear(),t&&this.setItem("_version",t),o.disconnect())}setItem(t,s){try{localStorage.setItem(this._prefix+t,s)}catch{}}getItem(t){try{return localStorage.getItem(this._prefix+t)}catch{return null}}removeItem(t){try{localStorage.removeItem(this._prefix+t)}catch{}}clear(){try{const t=localStorage.length,s=[];for(let e=0;e<t;e++){const n=localStorage.key(e);(n.startsWith(this._prefix)||n.startsWith("_web3w_"))&&s.push(n)}for(const e of s)try{console.log(`removing ${e}...`),localStorage.removeItem(e)}catch{}}catch{}}}var u=new O(p.contracts.OuterSpace.address+(p.contracts.OuterSpace.linkedData.chainGenesisHash?":"+p.contracts.OuterSpace.linkedData.chainGenesisHash:""));const m=typeof window!="undefined"?window.nacl:{},L="_local_only_";function v(i,t){return`${L}_${i.toLowerCase()}_${t}`}class R{constructor(){this.cache={},this.stopWalletSubscription=void 0,this.stopChainSubscription=void 0,this.lastChainId=void 0,this.lastWalletAddress=void 0,this.state={step:"IDLE",syncEnabled:!0},this.store=A(this.state,this._start.bind(this))}get signer(){return this.state.signer}subscribe(t,s){return this.store.subscribe(t,s)}login(){return this.execute()}execute(t){return this._promise?this._promise.then(()=>({contracts:this._contracts,signer:this.state.signer})):(this.state.step!=="READY"&&(this.state.step="CONNECTING",this._notify()),_.execute(e=>this.state.step!=="READY"?(this.state.step="SIGNATURE_REQUIRED",this._notify(),this._promise=new Promise((n,a)=>{this._contracts=e,this._resolve=n,this._reject=a,t&&(this._func=()=>t(this.state.signer,e))}),this._promise):t?t(this.state.signer,e):Promise.resolve()).then(e=>({signer:this.state.signer,contracts:e})))}async confirm({storeSignatureLocally:t,syncRemotely:s}){if(this.state.step!=="SIGNATURE_REQUIRED")throw new Error('confirm can only be executed when on step: "SIGNATURE_REQUIRED"');if(this.state.step="SIGNATURE_REQUESTED",this._notify(),!o.provider)return this.cancel(!1,new Error("no wallet.provider"));if(!o.address)return this.cancel(!1,new Error("no wallet.address"));if(!o.chain.chainId)return this.cancel(!1,new Error("no chainId, not connected?"));const e=o.chain.chainId,n=E(e);try{const a=o.address.toLowerCase(),h=await o.provider.getSigner().signMessage(`Only sign this message on "conquest.eth" or other trusted frontend.
This is for ${n}`),{signer:r,aesKey:c,messagingKey:l,signingKey:d}=await this._generateKeys(h);this.cache[a+"_"+e]={signer:r,aesKey:c,messagingKey:l,signingKey:d,syncEnabled:s};const g=JSON.stringify({signature:t?h:void 0,syncEnabled:s});u.setItem(v(a,e),g),this.state.step="READY",this.state.syncEnabled=s,this.state.signer=r,this.state.aesKey=c,this.state.messagingKey=l,this.state.signingKey=d,this.state.ownerAddress=o.address,this.state.chainId=e,this._notify(),this._func&&await this._func()}catch(a){return this.cancel(a)}this._resolve&&this._resolve(),this._resolve=void 0,this._reject=void 0,this._promise=void 0,this._contracts=void 0}cancel(t=!1,s){_.cancel(),t&&this._clear(!1),s&&this._reject&&this._reject(s),this._resolve=void 0,this._reject=void 0,this._promise=void 0,this._contracts=void 0}_start(){return this.stopWalletSubscription=o.subscribe(async t=>{this.lastWalletAddress!==t.address&&(this.lastWalletAddress=t.address,this.lastChainId&&await this._handleWalletAndChainChange(this.lastWalletAddress,this.lastChainId))}),this.stopChainSubscription=x.subscribe(async t=>{this.lastChainId!==t.chainId&&(this.lastChainId=t.chainId,this.lastWalletAddress&&await this._handleWalletAndChainChange(this.lastWalletAddress,this.lastChainId))}),this._stop.bind(this)}async _handleWalletAndChainChange(t,s){if(console.log(`_handleWalletAndChainChange(${t}, ${s})`),!t||!s){this._clear();return}const e=t.toLowerCase(),n=this.state.ownerAddress?this.state.ownerAddress.toLowerCase():void 0;if(e!==n||this.state.chainId!==s){this._clear(!0);let a=this.cache[e+"_"+s];if(!a){const h=u.getItem(v(e,s));if(h){let r;try{r=JSON.parse(h)}catch(c){console.error(c)}if(r){const c=r.signature,l=r.syncEnabled;if(c){const{signer:d,aesKey:g,messagingKey:w,signingKey:b}=await this._generateKeys(c);a=this.cache[e+"_"+s]={signer:d,aesKey:g,messagingKey:w,signingKey:b,syncEnabled:l}}else this.state.syncEnabled=r.syncEnabled,this.state.ownerAddress=t,this.state.chainId=s,this._notify()}else this.state.ownerAddress=t,this._notify()}else this.state.ownerAddress=t,this._notify()}a&&(this.state.step="READY",this.state.syncEnabled=a.syncEnabled,this.state.signer=a.signer,this.state.aesKey=a.aesKey,this.state.messagingKey=a.messagingKey,this.state.signingKey=a.signingKey,this.state.ownerAddress=t,this.state.chainId=s,this._resolve&&this._resolve(),this._resolve=void 0,this._reject=void 0,this._promise=void 0,this._contracts=void 0,this._notify())}}_clear(t=!0,s=!0){this.state.step="IDLE",t&&(this.state.syncEnabled=!0),this.state.signer=void 0,this.state.aesKey=void 0,this.state.messagingKey=void 0,this.state.signingKey=void 0,this.state.ownerAddress=void 0,this.state.chainId=void 0,s&&this._notify()}_stop(){this.stopWalletSubscription&&(this.stopWalletSubscription(),this.stopWalletSubscription=void 0),this.stopChainSubscription&&(this.stopChainSubscription(),this.stopChainSubscription=void 0)}_notify(){this.store.set(this.state)}getState(){return this.state}async _generateKeys(t){const s=new K(t.slice(0,130)),e=await s.signMessage("AES KEY"),n=W.utils.hex.toBytes(e.slice(2,66)),a=m.box.keyPair.fromSecretKey(new Uint8Array(t.slice(2,66).match(/.{1,2}/g).map(r=>parseInt(r,16)))),h=m.sign.keyPair.fromSeed(a.secretKey);return{signer:s,aesKey:n,messagingKey:a,signingKey:h}}hashString(){if(!this.state.signer)throw new Error("no signer");return N(["bytes32","bytes32"],[this.state.signer.privateKey.slice(0,66),"0x"+this.state.signer.privateKey.slice(66,130)])}}const k=new R;typeof window!="undefined"&&(window.privateWallet=k);export{J as a,Y as b,G as c,$ as d,F as e,Q as f,u as l,k as p,P as t};
//# sourceMappingURL=privateWallet-7a0cfca0.js.map
